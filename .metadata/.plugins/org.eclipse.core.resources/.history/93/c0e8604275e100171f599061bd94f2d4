/*
 * Sujets traités : 
 * - variables, types de variables
 * - instruction de contrôle
 * - opérateurs
 * - tableaux
 * - évoquer quelques classes souvent utilisées
 * - méthodes, paramêtres et passage de paramêtres
 * - etc
 */
package com.m2i.formation;

import java.math.BigDecimal;
import java.text.DecimalFormat;
public class Fondamentaux 
{
	public static void main(String[] args) 
	{
		float vf = 0.123456789123456789f;
		DecimalFormat df = new DecimalFormat("######.00");
		System.out.println("vf : " + df.format(vf));
		
		df =  new DecimalFormat("######.##");
		System.out.println("vf : " + df.format(vf));
		
		// une autre façon de formater les valeurs en sortie est d'utiliser 
		// le format C like
		
		System.out.printf("vf=%.1f, rapport = %f", vf, 1.f/3);
		
		// on a constaté plus haut que le précision dans un float est d'nviron 7 décimales
		// et celle d'un double d'environ 17 décimales 
		// Parfois, cette précision ne suffit pas
		
		System.out.println("1.3 - 1.2 = " + (1.3f - 1.2f));
		System.out.println("1.3 - 1.2 = " + (1.3 - 1.2));
		
		// pour résoudre un tel cas où la précision est vraiment necessaire, on 
		// peut utiliser la classe BigDecimal
		
		BigDecimal bd1 = new BigDecimal("1.3");
		BigDecimal bd2 = new BigDecimal("1.2");
		
		System.out.println("1.3 - 1.2 = " + bd1.subtract(bd2));
		
		// autres types prédéfinis (primaires)
		/*
		 * short : entier sur 2 octets
		 */
		
		System.out.println("A + 3 = " + 'A' + 3 );
		System.out.println("A + 3 = " + ('A' + 3) );
		System.out.println("A + 3 = " + (char)('A' + 3) );
		
		/*
		 * dans l'instruction précédente ont a utilisé un transtypage (cast) explicite 
		 * Java peut utiliser des transtypage implicites aussi : 
		 * Exemple : int -> long, float -> double
		 *
		 */
		
		int i = 3;
		long l = i;
		/*
		 * Java transforme implicitement la valeur int de i en valeur
		 * long. La réciproque n'est pas vraie
		 * i = l; erreur, on ne peut pas caster implicitement un long en int 
		 * dans ce cas, je dois assumer moi-même la responsabilité de tronquer 
		 * et demander un cast explicite
		 */
		
		i = (int)l;
		l = Integer.MAX_VALUE + 1;
		System.out.println("l =" +1);
		i = (int)l;
		/*
		 * Attention : la valeur sera modifiée si elle dépasse la possibilité
		 * de stockage d'un type int
		 */
		System.out.println("i = "+i);

		/* 
		 * D'autres casts explicites sont impossible et ils ne seront pas acceptés par 
		 * le compilateur
		 */
		
		/*
		 * i = (int)"123" => cast rejeté par le compilateur
		 */
		
		/*
		 * les classes qui contiennent des informations concernant les types
		 * primaires (prédéfinis) contiennent des méthodes utilitaires de type parse() 
		 * qui obtiennent une valeur numérique à partir d'une chaine de caractères
		 *  
		 */
		i = Integer.parseInt("123");
		System.out.println("\"123\" + 1 = " + "123" + i);
		System.out.println("i + 1 = " + (i +1));
		
		// même chose pour un réel simple précision (float)
		
		vf = Float.parseFloat("123.45");
		
	}
}
